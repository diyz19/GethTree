[[TOC]]

# 前言
本实验基于仓库根目录中的“实验说明.rar”解压后获得的三个节点进行实验。实验目的如下：

- [x] 启动三个节点（下称w1,w11和w12）
- [x] 令w1和w11,w12互相连通
- [ ] 根据仓库根目录中的“树状多链和资产转移测试.md”，进行一些测试
  - [ ] 运行数据同步测试
  - [ ] 运行跨链资产转移测试

# 启动分支节点w1，叶子节点w11和叶子节点w12

## 启动分支节点w1

首先修改节点初始化的脚本`w1_init.sh`。

```bash
#!/bin/sh

node_dir=../geth_w1

# 正常版本
geth-tree --identity "MyEth" --rpc --rpcport "8549" --rpccorsdomain "*" \
    --datadir "$node_dir/gethdata" --port "30309" --nodiscover \
    --rpcapi "eth,net,personal,web3,miner" --networkid "w1" \
    init "$node_dir/genesisgtrie.json"

# 无log
geth-tree --identity "MyEth" --rpc --rpcport "8549" --rpccorsdomain "*" \
    --datadir "$node_dir/gethdata" --port "30309" --nodiscover \
    --rpcapi "eth,net,personal,web3,miner" --networkid "w1" --syncmode "branch" \
    --allow-insecure-unlock --dev.period 1 --preload "w1_setbranch.js" console
```

终端中执行`sh w1_init.sh`即可启动节点。

在打开的JS控制台中输入`admin.nodeInfo.enode`，将输出信息复制下来备用。笔者这里获得的enode信息为`"enode://9382213a74dec4c63180a6869d6fae9006726ea26da84680b8eb223d9a08da6f8e674226a9b04ad7d602f882db442b495b415bfc7174b7323dbe11b8b8c04eb0@127.0.0.1:30309?discport=0"`

## 启动叶子节点w11和w12

首先编辑`w11_1_addPeer.js`，将开头的`admin.addPeer`中的地址替换为我们上一步获得的enode信息：

```js
admin.addPeer("enode://9382213a74dec4c63180a6869d6fae9006726ea26da84680b8eb223d9a08da6f8e674226a9b04ad7d602f882db442b495b415bfc7174b7323dbe11b8b8c04eb0@127.0.0.1:30309?discport=0")
// -- snip --
```

再将`w11_1_init.sh`修改为如下：

```bash
#!/bin/sh

node_dir=../geth_w11_1

geth-tree --identity "MyEth" --rpc --rpcport "8511" --rpccorsdomain "*" \
    --datadir "$node_dir/gethdata" --port "30311" --nodiscover \
    --rpcapi "eth,net,personal,web3,miner" --networkid "w11" \
    init "$node_dir/genesisgtrie.json"

geth-tree --identity "MyEth" --rpc --rpcport "8511" --rpccorsdomain "*" \
    --datadir "$node_dir/gethdata" --port "30311" --nodiscover \
    --rpcapi "eth,net,personal,web3,miner" --networkid "w11" --allow-insecure-unlock \
    --dev.period 1 --preload "w11_1_addPeer.js" console
```

终端执行`sh w11_1_init.sh`即可启动节点w11。

为确保w11已经连接到w1，可以在终端中输入`admin.peers`，如果输出了一个`object`列表，那么w11已经成功与w1建立连接。

启动w12的过程和w11类似，此处不再赘述。

# 进行实验

## 运行数据同步测试

首先，在w11和w12中开启挖矿：

```js
// 在w11的终端中输入，开启挖矿
miner.start(1)
// 在w12的终端中输入，开启挖矿
miner.start(1)
```

然后，新建一个终端，在其中执行：
```bash
//分开
node w2_commontx.js
node w3_commontx.js
//合并
node sync_test.js
```

**发生错误！！** 执行`node w2_commontx.js`之后，节点w11就停止了工作，同时在运行node的终端出现了这样的报错信息：
```
/home/endericedragon/ExperimentsWithGethTree/实验说明/test_file/w2_commontx.js:19
var _value = w2_web3.toWei(10,"ether");
                     ^

TypeError: w2_web3.toWei is not a function
    at Object.<anonymous> (/home/endericedragon/ExperimentsWithGethTree/实验说明/test_file/w2_commontx.js:19:22)
    at Module._compile (node:internal/modules/cjs/loader:1159:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1213:10)
    at Module.load (node:internal/modules/cjs/loader:1037:32)
    at Module._load (node:internal/modules/cjs/loader:878:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)
    at node:internal/main/run_main_module:23:47

Node.js v18.12.1
```

定位到报错的第19行，按照网络上的说法将其修改为：
```js
var _value = w2_web3.utils.toWei("10","ether");
```

其一是增添了`.utils`，其二是将`10`改为了`"10"`。由此推测，`w3_commontx.js`也需要如此修改。

修改过后尝试重启节点w11，却获得报错：
```
WARN [03-21|22:05:46.055] Served eth_setBranchBlock                reqid=4 t=46.682µs err="The branch already exists"
Fatal: Failed to start the JavaScript console: w11_1_addPeer.js: Error: The branch already exists
        at web3.js:6358:37(47)
        at web3.js:5081:62(37)
        at w11_1_addPeer.js:5:19(29)
```

因为在之前的步骤中分支已经建立，那么此时重新建立一样的分支显然会引发错误。因此，我们可以修改`w11_1_addPeers.js`为：

```js
// -- snip --
// 使用eth.getBranchBlockByRegion()判断分支是否存在，仅当不存在时才设置分支
if (eth.getBranchBlockByRegion("w11") === null) {
    eth.setBranchBlock({ from: eth.accounts[0], branchid: "w11", settime: 20 })
}

eth.getBranchBlockByRegion("w1")  // 据说不加上这句话有概率令w11连接不到w1
// -- snip --
```

`w12_1_init.sh`也可以类似修改。修改完成之后，再次尝试启动节点w11，w12，节点运行正常。

**发生错误！！** 节点w1重启之后，节点w11和w12发现不了它了！

解决方案：联系前辈后得知，在这些节点中第二次启动之后，需要使用`eth.getBranchBlockByRegion()`函数，分别访问自己以及需要与自己相连的节点，最后执行一次`admin.addPeer()`，才能成功建立连接。例如，节点w1需要连接w11和w12，那么它就需要在启动之后执行：

```js
eth.getBranchBlockByRegion("w1")  // 访问自己
eth.getBranchBlockByRegion("w11")  // 访问需要连接的w11
eth.getBranchBlockByRegion("w12")  // 访问需要连接的w12
```

再等待数秒，即可建立连接。

受到启发，笔者如此修改`w1+setbranch.js`，问题解决：

```js
if (eth.getBranchBlockByRegion("w1") === null) {
    eth.setBranchBlock({ from: eth.accounts[0], branchid: "w1", settime: 10 })
} else {
    // 二次启动，需要访问
    eth.getBranchBlockByRegion("w11")
    eth.getBranchBlockByRegion("w12")
}
```

同时，在`w11_1_addPeers.js`和`w12_1_addPeers.js`的末尾，也相应加入了`admin.addPeer()`

继续启动挖矿，并执行`node w2_commontx.js`，结果获得如下报错：
```
Error: CONNECTION ERROR: Couldn't connect to node http://localhost:8542.
```

这是咋回事呢？原来节点w11根本不工作在8542号端口上，而是在8511号端口上（详见`w11_1_init.sh`）。同理，节点w12工作在8521端口上，因此`w3_commontx.js`也必须作相应修改。

**发生错误！！** 还是连不上。经过讨论，笔者计划直接跳过该实验进行下一个。

## 运行跨链资产转移实验

按照“树状多链和资产转移测试.md”中的说法，首先需要在w11，w12中开启挖矿，然后依次使用node执行`transfer_test3.js`和`branchnode2.js`两个脚本的内容，最后停止挖矿，观察两个叶子节点里的账户的余额变化。






